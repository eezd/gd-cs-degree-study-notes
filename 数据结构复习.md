# 数据结构复习

配合串讲笔记学

- **概论**

  - 时间复杂度按数量级，常数阶对数阶那些

- **第二章 线性表**

  - 线性的逻辑结构
  - 生成结点变量：`p=( ListNode *)malloc(sizeof(ListNode))`

- **第四章 数组**

  - **按照行和列优先存储的公式**
  - 数组和矩形的存储地址计算是不同的
    - 数据是：$LOC(a_(ij))=LOC(a_(00))+(i*n+j)*k$
    - 矩形是：
      - $Aij=Loc00+(i*n + j)*d$
      - $Aij=Loc00+(j*m + i)*d$

- **顺序表**
  - 插入运算平均移动：`n/2`
  - 插入一个节点需要一运动：`n-i+1`
  - 求地址：$Loc(a_i) = Loc(a_1) + c *(i-1)$
- 顺序栈
  - 栈空：`s->top==0`
  - 栈满：`s->top==maxsize -1`
- 链式栈
  - 下溢：`LS->next == NULL`
- 队列
  - 入队出队：`sq.rear=sq.rear+1`、`sq.front=sq.front+1`
  - 上溢：`sq.rear == maxsize-1`
  - 下溢：`sq.rear == sq.front`
- 循环队列
  - 入队：`Sq.rear=(sq.rear+1)%maxsize`
  - 出队：`Sq.front=(sq.front+1)%maxsize`
  - 上溢：`CQ.front==CQ.rear`
  - 下溢：`(CQ.rear+1)%maxsize==CQ.front`
- 数组
  - 行优先 A mXn，n 优先：$Aij=Loc00+(i*n + j)*d$
  - 列优先 A mXn，m 优先：$Aij=Loc00+(j*m + i)*d$
  - **数组也是从 0 开始算，！计算存放多少字符，如果下标是从 0 开始，那么需要+1**
- 矩阵
  - 对称矩形的元素总数：`n * ( n + 1 ) /2`
  - 对称矩形地址计算：`LOC(Aij)=LOC(sa[0]) + i*(i+1)/2+j`
  - 三元表：置换前-行列值，置换后-列行值
  - **矩形是从 0 开始，如果是从 A11 开始则 - 1**
- 线索二叉树
  - 空的线索数：`n+1`
- 树的存储结构
  - 双亲表示：数据域和双亲域，双亲域存放编号
  - 孩子链表：数据域和孩子域，向右延伸，链表（存放数字）
  - 孩子兄弟链表表示：采用二叉链表表示，左边指向`第一个孩子`，右边指向`兄弟`
- **树的后序遍历=二叉树中序**
- 哈夫曼树
  - WPL 计算：全部加在一起，无需除法
  - 生成哈夫曼树：小的在左子树，大的在右子树。
  - 哈夫曼编码：左边 0，右边 1
- 图
  - 无向图最少：n-1，最多：n(n-1)/2
  - 有向图：n，最多：n(n-1)
  - **要保持非连通状态**边需要 + 1（！！重要！！）
  - 邻接矩阵：0 和 1 组成
    - ![图-图的邻接矩阵表示法](imgDS\图-图的邻接矩阵表示法.png)
  - 邻接表：自己指向谁，逆邻接表：谁指向自己
    - ![图-邻接表表示法的向量图例](imgDS\图-邻接表表示法的向量图例.png)
- 最小生成树
  - Prim，**根据顶点集找到最短的路径，根据顶点的连接关系找**
  - Kruskal，**根据最短路径去选择**
  - Dijkstra，**从一个点出发，计算该点去其他节点的，最短路径**
- 查找
  - 顺序查找，查找成功的平均查找长度：`(n+1)/2`，不成功：`n+1`
  - 二分查找，成功时次数最多：$log_2^{(n+1)}$ - 1
  - 分块查找
  - 二分查找平均查找长度（将节点画棵树带入）：前面的数字代表`第几层`，后面的数字代表`节点数`，最后除`节点总数`，$(1*1+2*2+3*4+4*3)/10$
- **二叉排序树**
  - A.**若右子树非空，则右子树上所有结点的值均大于根节点的值**
  - B.**若左子树非空，则左子树上所有结点的值均小于根节点的值**
  - **平衡二叉树**
    - 小的放在左边，大的放在右边
  - B 树
    -
- 散列函数
  - 直接地址法：H(key) = key + C
  - 数字分析法
  - 除留余数法：H(key)= key mod p
  - 平方取中法
  - 折叠法
- 处理冲突
  - 开放定址法——线性探查法
    - `H(key)=key mod m`，如被占用则采用下一位
    - 散列表个数=m
  - 开放定址法——二次探查法
    - $h_i = （H（key） \pm \ i^2）$% m
  - 拉链法
    - ![查找-拉链法2](imgDS\查找-拉链法2.png)
